# 10장 리액트 17과 18의 변경 사항 살펴보기

- [10장 리액트 17과 18의 변경 사항 살펴보기](#10장-리액트-17과-18의-변경-사항-살펴보기)
  - [10.2 리액트 18 버전 살펴보기](#102-리액트-18-버전-살펴보기)
    - [10.2.3 react-dom/server](#1023-react-domserver)
    - [10.2.4 자동 배치(Automatic Batching)](#1024-자동-배치automatic-batching)
    - [10.2.5 더욱 엄격해진 엄격 모드](#1025-더욱-엄격해진-엄격-모드)
    - [10.2.6 Suspense 기능 강화](#1026-suspense-기능-강화)
    - [10.2.7 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요](#1027-인터넷-익스플로러-지원-중단에-따른-추가-폴리필-필요)
    - [10.2.8 그 밖에 알아두면 좋은 변경사항](#1028-그-밖에-알아두면-좋은-변경사항)
    - [10.2.8 정리](#1028-정리)

## 10.2 리액트 18 버전 살펴보기

### 10.2.3 react-dom/server

클라이언트의 변화와 마찬가지로 서버에서 컴포넌트를 생성하는 API 변경이 있었습니다. 어떤것들이 추가되었는지 살펴 보겠습니다.

`renderToPipeableStream`

리액트 컴포넌트를 HTML로 렌더링하는 메서드 입니다.

스트림을 지원하는 메서드로 HTML을 점진저긍로 렌더링하고 클라이언트에서는 중간 script를 삽입하는 등의 작업을 할 수 있습니다.
서버에서 Suspense를 사용하여 빠르게 렌더링이 필요한 부분을 먼저 렌더링을 할 수 있고, 값 비싼 연산으로 구성된 부분은 이후에 렌더링 되게끔 할 수 있습니다.

예제 코드를 살펴보겠습니다

```js
function render(url, res) {  // res 는 HTTP 응답
  let didError = false

  // 서버에서 필요한 데이터를 불러오고, 데이터를 불러오는데 시간이 오래걸린다고 가정해보기
  const data = createServerData()
  const stream = renderToPipeableStream(

    // 데이터를 Context API 로 넘기기
    <DataProvider data={data}>
    <App assets={assets}>
    </DataProvider>,
    {
      boostrapScripts : [assets['main.js']],
      onShellReady() {
        // 에러 발생 시 처리 추가
        res.statusCode = didError ? 500 : 200
        res.setHeader('Content-type', 'text/html')
        stream.pipe(res)
      },
      onError(x) {
        didError = true
        console.log(x)
      },
    },
  )
  // 렌더링 시작 이후 일정 시간이 흐르면 렌더링에 실패한 것으로 간주 후 취소
  setTimeOut(() => stream.abort(), ABORT_DELAY)
}

export default function App({assets}) {
  return (
    <Html assets={assets} title='Hello'>
    <Suspanse fallback={<Spinner>}>
    <ErrorBoundary FallbackComponent={Error}>
    <Content/>
    </ErrorBoundary>
    </Suspanse>
    </Html>
  )
}

function Content(){
  return (
    <Layout>
    <NavBar/>
<article className="post">
<section className='comments'>
<h2>Comments</h2>
// 데이터가 불러오기 전 보여줄 컴포넌트
    <Suspanse fallback={<Spinner>}>
// 데이터가 불러오기 전 보여줄 컴포넌트
<Comments/>
</section>
<h2>Thanks for reading!</h2>
</article>
    <Layout/>
  )
}
```

`renderToPipeableStream` 을 사용하면 최초에 브라우저는 아직 불러오지 못한 데이터 부분을 Suspense 의 fallback 으로 받는다.

그리고 `createServerData` 의 데이터 로딩이 끝나면 `<Comments/>` 가 데이터를 가지고 렌더링이 됩니다.

원래라면 렌더링이 순서대로 진행이되고, 순서에 의존하기에 이전 렌더링이 완료되지 않는다면 이후 렌더링도 끝나지 않는다. 였었습니다.
그러나 이번에 추가된 `renderToPipeableStream` 을 활용하면 순서나 오래 걸리는 렌더링에 영향 받을 필요 없이 빠르게 렌더링을 수행할 수 있습니다.

사용하는 경우가 거의 없겠지만 참고정도 하시면 좋을듯합니다 !

### 10.2.4 자동 배치(Automatic Batching)

`자동 배치 (Automatic Batching)`은 리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법을 의미합니다. 예를 들면 버튼 클릭 한 번에 두 개 이상의 state를 동시에 업데이트한다고 사정해보면 자동배치는 이를 하나의 리렌더링으로 묶어서 수행이 가능합니다.

```ts
const sleep = (ms: number) => {
  return new Promise((resolve) => setTimeOut(resolve, ms));
};

export default function App() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  const callback = useCallback(
    (id, phase, actualDuration, baseDuration, startTime, commitTime) => {
      console.group(phase);
      console.table({ id, phase, commitTime });
      console.groupEnd();
    },
    []
  );

  useEffect(() => {
    console.log("rendered");
  });

  function handleClick() {
    sleep(3000).then(() => {
      setCount((c) => c + 1);
      setFlag((f) => !f);
    });
  }
}

return (
  <Profiler id="React18" onRender={callback}>
    <button onClick={handleClick}> next </button>
    <h1 style={{ color: flag ? "blue" : "black" }}>{count}</h1>
  </Profiler>
);
```

아래 사진은 위의 예시 코드 결과를 가져온 모양입니다.

위의 사진은 React 17 아래 사진은 React 18 인데
18 에서의 자동배치를 이용하여 리렌더링이 한번만 되는걸 확인할 수 있습니다.
![Alt text](KakaoTalk_Photo_2024-01-18-13-01-13.jpeg)

17 이하의 버전에서는 이벤트 핸들러 내부에서는 자동 배치 작업이 이뤄지고 있었지만 Promise, setTimeOut 같은 비동기 이벤트에서는 자동배치가 이뤄지지 않았다고 합니다.

즉, 동기와 비동기 배치 작업에 일관성이 없었고, 이를 보완하기위해서 18버전부터는 루트 컴포넌트를 createRoot를 사용해 만들어서 모든 업데이트가 배치 작업으로 최적화 할 수 있게 만들었다고 합니다.

```js
const rootElement = document.gerElementById("root");
const root = ReactDOM.createRoot(rootElement);

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

자주 보셨을 이 코드는 자동배치가 활성화되어 리액트 동기, 비동기, 이벤트 핸들러 등에 관계 없이 렌더링을 배치로 수행하게 합니다.

### 10.2.5 더욱 엄격해진 엄격 모드

### 10.2.6 Suspense 기능 강화

### 10.2.7 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

### 10.2.8 그 밖에 알아두면 좋은 변경사항

### 10.2.8 정리
